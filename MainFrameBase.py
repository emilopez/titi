# -*- coding: utf-8 -*-
"""Subclass of MainFrameBase, which is generated by wxFormBuilder."""

import wx
import gui
import rasterIO
import numpy as np
import matplotlib.cm as cm
import module as m
from MasiveCalcsFrame import MasiveCalcsFrame

# Implementing MainFrameBase
class MainFrameBase( gui.MainFrameBase ):
    def __init__( self, parent ):
        gui.MainFrameBase.__init__( self, parent )
        self.m_canvas.SetInitialSize(wx.Size( 500,500 ))
        self.m_canvas_preview.SetInitialSize(wx.Size( 200,200 ))

    # Handlers for MainFrameBase events.
    def onOpenFile( self, event ):

        # Show in status bar and log
        self.filename = self.m_btn_file.GetPath()
        self.m_txt_log.AppendText("#### Opened File #### \n"+self.filename)
        self.m_statusBar.SetStatusText(self.filename)

        # Load image with PyRaster
        self.file_pointer = rasterIO.opengdalraster(self.filename)
        driver, self.XSize, self.YSize, self.NBand, proj_wkt, geo = rasterIO.readrastermeta(self.file_pointer)
        self.lon0,self.lat0,self.dlon,self.dlat = geo[0],geo[3],geo[1],geo[5]

        # Clean band combobox, and load existing bands (Default band: 1)
        self.m_cmb_band.Clear()
        bands = [str(b) for b in range(1,self.NBand+1)]
        self.m_cmb_band.AppendItems(bands)
        self.m_cmb_band.SetValue('1')

        # Get selected band
        self.data = rasterIO.readrasterband(self.file_pointer, int(self.m_cmb_band.GetValue()))
        self.data = self.data.astype(np.float32)

        # Create figure with the colormap selected
        self.m_figure.clear()
        self.ax = self.m_figure.add_subplot(111)
        eval("self.ax.imshow(self.data, cmap = cm."+self.m_cmb_colormap.GetValue()+")")

        # Latitude and longitude range
        max_lat = self.lat0 + self.YSize*self.dlat
        max_lon = self.lon0 + self.XSize*self.dlon

        # Show and Log figure metadata
        sms = "\n+ Metadata \n    " + proj_wkt +"\n"
        sms += "    - Size = " + str(self.YSize) + "," + str(self.XSize) + "\n"
        sms += "    - Delta latitude = " + str(self.dlat) + "\n    - Delta longitude = " + str(self.dlon) + "\n"
        sms += "    - Latitude limits: \n"
        sms += "        from = "+ str(self.lat0) + "\n"
        sms += "        to   = "+ str(max_lat) + "\n"
        sms += "    - Longitude limits: \n"
        sms += "        from = "+ str(self.lon0) + "\n"
        sms += "        to   = "+ str(max_lon) + "\n"
        self.m_txt_log.AppendText(sms)
        self.m_txt_log.ShowPosition( self.m_txt_log.GetLastPosition())

        # Set axes labels
        self.ax.set_xlabel('Col (Lon)')
        self.ax.set_ylabel('Row (Lat)')

        # Draw figure
        self.ax.grid(True)
        self.m_canvas.draw()

    def onCmapChanged( self, event ):
        # Redraw the image with the new selected colormap
        eval("self.ax.imshow(self.data, cmap = cm."+self.m_cmb_colormap.GetValue()+")")
        self.m_canvas.draw()
	
    def onBandChanged( self, event ):
        # Reload the image with the band selected
        self.data = rasterIO.readrasterband(self.file_pointer, int(self.m_cmb_band.GetValue()))
        self.data = self.data.astype(np.float32)
        eval("self.ax.imshow(self.data, cmap = cm."+self.m_cmb_colormap.GetValue()+")")
        self.m_canvas.draw()

    def onExtractInputTypeClick( self, event ):
        # Set the input of extract method, row/col or lat/lon
        choice = self.m_rBox_extract_input_type.GetStringSelection()
        if choice == "Row/Col":
            self.m_stxt_lat.SetLabel("Row")
            self.m_stxt_lon.SetLabel("Column")
        else:
            self.m_stxt_lat.SetLabel("Latitude")
            self.m_stxt_lon.SetLabel("Longitude")

    def onExtractClicked( self, event ):
        # Get the value from image
        choice = self.m_rBox_extract_input_type.GetStringSelection()
        if choice == "Row/Col":
            row = float(self.m_txt_lat.GetValue())
            col = float(self.m_txt_lon.GetValue())

            # Only to be logged
            lat,lon = m.getLatLon(row,col,self.lat0, self.lon0, self.dlat, self.dlon)
        else:
            lat = float(self.m_txt_lat.GetValue())
            lon = float(self.m_txt_lon.GetValue())

            # Image indexes
            row,col = m.getRowCol(lat,lon,self.lat0, self.lon0, self.dlat, self.dlon)

        # Format the info to be logged
        sms = "\n+ Extract operation \n"
        sms += "     Lat = "+ str(lat) + "\n"
        sms += "     Lon = "+ str(lon) + "\n"
        sms += "     Row = "+ str(row) + "\n"
        sms += "     Col = "+ str(col) + "\n"
        self.m_txt_log.AppendText(sms)

        if ( self.YSize < row or row < 0 ) or (self.XSize < col or col < 0 ):
            # if row or col are out of bounds
            self.m_txt_log.AppendText("\n Error: Row or column out of bouds")
        else:
            self.m_txt_extracted_value.SetValue(str(self.data[row][col]))
            self.m_txt_log.AppendText("     Extracted value = "+str(self.data[row][col]))

        # Scroll to show the las log added
        self.m_txt_log.ShowPosition( self.m_txt_log.GetLastPosition())
		
    def onFigureClicked( self, event ):
        # TODO: Implement onFigureClicked
        pass
	
    def onActivateApp( self, event ):
        pass

    def onEnterAxes( self, event ):
        pass

    def onLeaveAxes( self, event ):
        pass

    def onMouseMotion( self, event ):
        # Show row,col,lat,lon,image value of pixel in status bar
        # and a small zoom in other preview image
        if (0 <= event.xdata <= self.XSize) and (0 <= event.ydata <= self.YSize):

            # Mouse over the image
            col,row = int(event.xdata), int(event.ydata)
            # Warning! if row-5 or col-5 is negative => out of bounds
            lat,lon = m.getLatLon(row,col,self.lat0, self.lon0, self.dlat, self.dlon)

            # Status bar sms
            sms = "Row,Col = ["+str(row) + "," + str(col) + "]     |     Lat,Lon =  [" + str(lat) + "," + str(lon) + "]"
            sms += "    |    Value = " + str(self.data[row,col])
            self.m_statusBar.SetStatusText(sms)

            # Load small zoom
            self.m_figure_preview.clear()
            self.ax2 = self.m_figure_preview.add_subplot(111)
            eval("self.ax2.imshow(self.data[row-5:row+5,col-5:col+5], cmap = cm." + self.m_cmb_colormap.GetValue() + ")")
            self.m_canvas_preview.draw()

    def onZoom( self, event ):
        # Zoom on scroll mouse wheel
        # max x and y limits
        cur_xlim = self.ax.get_xlim()
        cur_ylim = self.ax.get_ylim()

        # x and y range
        cur_xrange = (cur_xlim[1] - cur_xlim[0])*.5
        cur_yrange = (cur_ylim[1] - cur_ylim[0])*.5

        if event.button == 'up':
            # zoom in
            scale_factor = 1./2
        elif event.button == 'down':
            # zoom out
            scale_factor = 2.

        # Renew the limits of the image and redraw
        self.ax.set_xlim([event.xdata - cur_xrange*scale_factor,event.xdata + cur_xrange*scale_factor])
        self.ax.set_ylim([event.ydata - cur_yrange*scale_factor,event.ydata + cur_yrange*scale_factor])
        self.m_canvas.draw()

    def onAboutSelected( self, event ):
        sms = 'Titi is Free Software under GPL v.3\n'
        sms += 'Version 0.2.0 \n'
        sms += 'Project site: https://github.com/emilopez/titi \n'
        sms += 'Author: Emiliano LÃ³pez - emiliano.lopez [AT] gmail.com'
        wx.MessageBox(sms, 'About Titi', wx.OK | wx.ICON_INFORMATION)

    def onMassiveCalcsSelected( self, event ):
        self.MassiveCalcs = MasiveCalcsFrame(None)
        self.MassiveCalcs.Show()
